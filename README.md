# AWS deployment scripts for Cadasta platform v1

There are a three steps to this, accessible via the `make-base-ami`,
`make-deploy-ami` and `deploy` scripts in the `scripts` directory.
However, it is also possible to use the same Ansible playbooks used
for setup on AWS in Vagrant for debugging purposes.  See the section
*Using Vagrant* below.


### Generating AMIs

Generation of the Amazon Machine Image used for deployment is done in
two steps:

1. An Ansible playbook is used to set up the base "fixed" parts of the
   installation (i.e. operating system package installation, etc.),
   using an EC2 instance to generate an Amazon Machine Image for later
   deployment.

2. A second Ansible playbook extends the base AMI to include the
   "fixed platform-specific" parts of the installation (source code
   installation, fixed configuration, etc.) to create a "deployment
   AMI".

The rationale for this is that there are a *lot* of operating system
dependencies that need to be installed, and these are likely to change
far less frequently than the platform code itself.  Breaking the AMI
generation into two steps means that the most frequent AMI updates
should be relatively quick.

The AMIs generated by these processes are registered in a
`machine-images.csv` file since they are AWS region-specific.  The
easiest way to do a deployment in a new region is simply to copy the
deployment AMI from an existing region using the AWS console or
command line and then to add an appropriate line to the
`machine-images.csv` file.

Each of the `make-base-ami` and `make-deploy-ami` scripts takes the
same parameters:

1. The name of an AWS configuration profile to use for accessing
   credentials to connect to AWS.  (Set one of these up using the `aws
   configure` command.)

2. The path to a private key file used for connecting to the sandbox
   EC2 instance used for generating the AMI.  (You'll need to use the
   `cadasta-utility` key pair for this.  Just ask me [Ian] and I can
   give it to you.  If I've left or been eaten by a grue, just destroy
   and recreate the `cadasta-utility` key pair and save the PEM file
   somewhere.)

So, if you have an AWS profile called `cadasta` that has permissions
to manipulate AWS entities belonging to the Cadasta account, you can
create a fresh base AMI like this:

```
./scripts/make-base-ami.py cadasta ~/.ssh/cadasta-utility.pem
```

The base AMI is built from the standard Ubuntu 14.04 LTS AMI for the
region being used and contains all of the operating system and
"external" software packages needed to support the Cadasta platform
code.  The base AMI should not need to be changed for code changes to
the Cadasta platform unless package dependencies change.

Then, whenever you want to create a new deployment AMI, you do:

```
./scripts/make-deploy-ami.py cadasta ~/.ssh/cadasta-utility.pem
```

The deployment AMI is built from the base AMI and contains all of the
Cadasta platform-specific software (i.e. source cloned from Cadasta
repositories) as well as fixed configuration settings that are
independent of the particular deployment.


### Deployment

A third Ansible playbook is used to perform the configuration and
deployment steps for the platform, based on per-instance information
collected by the `deploy` script.


### Installation steps

These are the Ansible roles in the `make-base-ami` playbook:

1. `ckan`: Install base CKAN and prerequisites.
2. `solr`: Install and configure Solr.
4. `angular`: Install Angular application OS prerequisites.
5. `api`: Install database and API prerequisites.
6. `ona`: Install and configure ONA.
7. `prereqs`: Install and configure deployment prerequisites.

These are the Ansible roles in the `make-deploy-ami` playbook:

3. `ckan_extension`: Install CKAN extension code.
4. `angular`: Install Angular application JS prerequisites.
5. `api`: Install database and API code.


### Using Vagrant

As well as making AMIs and deploying to an AWS EC2 instance, you can
also run all the Ansible provisioning steps within Vagrant, which is
handy for debugging.

To bring up a VM provisioned with the base image, go to
`playbooks/make-base-ami` and do `vagrant up --provision`.
Eventually, you'll end up with a running VM containing all the base
prerequisites for the Cadasta platform.  You can save this as a
Vagrant box for use later by doing

```
vagrant package --output /big/cadasta/cadasta-base.box
vagrant box add --name cadasta-base /big/cadasta/cadasta-base.box
```

Once you've made and registered a "base" box, you can bring up a
"deploy" VM by going to `playbooks/make-deploy-ami` and doing `vagrant
up --provision` -- this will work off of the `cadasta/base` box you
just created.  You can then save your "deploy" box in the same kind of
way as before:

```
vagrant package --output /big/cadasta/cadasta-deploy.box
vagrant box add --name cadasta-deploy /big/cadasta/cadasta-deploy.box
```

Once you've done this, you can test the deployment playbook in
`playbooks/deploy`.  First do `vagrant up --no-provision` to get the
VM running, then do the following to allow the VM access to your local
Postgres server (since we're not going to run Postgres on the VM, you
need a Postgres server locally):

```
vagrant ssh -- -R127.0.0.1:5432:/var/run/postgresql/.s.PGSQL.5432
```

Leave that SSH session active, and you can now do a `vagrant
provision`.


### AWS prerequisites

The AMI setup steps make use of some pre-existing AWS entities I
defined for utility purposes.  If these get deleted by accident,
you'll need to recreate them to be able to use these scripts:

 * A VPC subnet called `ami-builders` on the default VPC for the
   Cadasta AWS account.  Doesn't matter what CIDR (I used
   172.31.64.0/20).
 * A VPC security group called `cadasta-utility` with an inbound rule
   permitting SSH connections.
 * A key pair called `cadasta-utility` (you'll need the PEM file for
   this).
